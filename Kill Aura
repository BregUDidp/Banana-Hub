game.StarterGui:SetCore("SendNotification", {
    Title = ".‚öîÔ∏è Kill Aura Hub ‚öîÔ∏è.",
    Text = "ü¶ù [ .Cursed X Hub. ]",
    Duration = 5
})


game.StarterGui:SetCore("SendNotification", {
    Title = "[.‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 99 ‡∏Ñ‡∏∑‡∏ô.]",
    Text = "ü¶ù [ .Cursed X Hub. ]",
    Duration = 5
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Settings
local AUTO_KILL_ENABLED = false
local ATTACK_DELAY = 0.3 -- fast attacks (we're aggressive now)
local MAX_ATTACK_RADIUS = 100
local ENEMIES_PER_CYCLE = 200 -- attack 200 enemies at once (mass destruction mode)
local PRIORITIZE_CLOSEST = true -- focus on nearest threats first

local currentEnemyIndex = 1
local lastAttackTime = 0
local consecutiveFailures = 0
local lastFailureWarning = 0
local totalEnemiesKilled = 0

-- Error tracking
local errorCounts = {
    pcall_error = 0,
    nil_response = 0,
    server_error = 0,
    no_enemies = 0,
    no_weapon = 0
}
local lastErrorReport = 0

-- Cache remote
local toolDamageRemote = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToolDamageObject")

-- Print error summary
local function reportErrors()
    local currentTime = tick()
    if currentTime - lastErrorReport < 10 then return end
    
    local hasErrors = false
    for _, count in pairs(errorCounts) do
        if count > 0 then hasErrors = true break end
    end
    
    if hasErrors then
        print("üìä Error Summary (last 10s):")
        if errorCounts.pcall_error > 0 then print("  - pcall errors: x" .. errorCounts.pcall_error) end
        if errorCounts.nil_response > 0 then print("  - nil responses: x" .. errorCounts.nil_response) end
        if errorCounts.server_error > 0 then print("  - server errors: x" .. errorCounts.server_error) end
        if errorCounts.no_enemies > 0 then print("  - no enemies found: x" .. errorCounts.no_enemies) end
        if errorCounts.no_weapon > 0 then print("  - no weapon equipped: x" .. errorCounts.no_weapon) end
        
        for key in pairs(errorCounts) do
            errorCounts[key] = 0
        end
    end
    
    lastErrorReport = currentTime
end

-- Report consecutive failures
local function reportFailures()
    local currentTime = tick()
    if consecutiveFailures >= 10 and currentTime - lastFailureWarning >= 10 then
        print("‚ö†Ô∏è High failure rate: x" .. consecutiveFailures .. " consecutive failures")
        lastFailureWarning = currentTime
    end
end

-- Get the proper CFrame from enemy
local function getEnemyCFrame(enemy)
    if enemy.PrimaryPart then
        return enemy.PrimaryPart.CFrame
    end
    return enemy:GetPivot()
end

-- Check if enemy is alive
local function isEnemyAlive(enemy)
    if not enemy or not enemy.Parent then return false end
    
    -- check for humanoid health
    local humanoid = enemy:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health > 0 then
        return true
    end
    
    -- fallback: check Health attribute
    local health = enemy:GetAttribute("Health")
    if health and health > 0 then
        return true
    end
    
    return false
end

-- Get valid enemies in radius
local function getValidEnemiesInRadius()
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then return {} end

    local playerPos = character.PrimaryPart.Position
    local enemies = {}
    local charactersFolder = workspace:FindFirstChild("Characters")
    if not charactersFolder then return {} end

    for _, enemy in pairs(charactersFolder:GetChildren()) do
        -- skip if it's the player's character
        if enemy ~= character and isEnemyAlive(enemy) then
            local enemyCFrame = getEnemyCFrame(enemy)
            local enemyPos = enemyCFrame.Position
            local distance = (playerPos - enemyPos).Magnitude
            
            if distance <= MAX_ATTACK_RADIUS then
                -- get health info if available
                local health = nil
                local maxHealth = nil
                local humanoid = enemy:FindFirstChildOfClass("Humanoid")
                
                if humanoid then
                    health = humanoid.Health
                    maxHealth = humanoid.MaxHealth
                else
                    health = enemy:GetAttribute("Health")
                    maxHealth = enemy:GetAttribute("MaxHealth")
                end
                
                table.insert(enemies, {
                    enemy = enemy,
                    distance = distance,
                    health = health or 0,
                    maxHealth = maxHealth or 100,
                    name = enemy.Name
                })
            end
        end
    end

    -- sort by distance (closest threats first)
    if PRIORITIZE_CLOSEST then
        table.sort(enemies, function(a, b) return a.distance < b.distance end)
    end
    
    return enemies
end

-- Get equipped weapon
local function getWeapon()
    local character = LocalPlayer.Character
    if not character then return nil end

    local toolHandle = character:FindFirstChild("ToolHandle")
    if not toolHandle then return nil end

    local originalValue = toolHandle:FindFirstChild("OriginalItem")
    if not originalValue or not originalValue.Value then return nil end

    local toolName = originalValue.Value.Name
    local inventory = LocalPlayer:FindFirstChild("Inventory")
    if not inventory then return nil end

    return inventory:FindFirstChild(toolName)
end

-- Attack a single enemy (no delay version for mass attacks)
local function attackSingleEnemy(enemyData, weapon)
    local enemy = enemyData.enemy
    if not enemy or not enemy.Parent or not isEnemyAlive(enemy) then
        return false
    end

    local enemyCFrame = getEnemyCFrame(enemy)
    local args = { 
        enemy, 
        weapon, 
        tostring(math.random(1, 99)) .. "_" .. tostring(tick()):gsub("%.", ""):sub(1, 10),
        enemyCFrame 
    }

    local success, result = pcall(function()
        return toolDamageRemote:InvokeServer(unpack(args))
    end)

    if not success then
        errorCounts.pcall_error = errorCounts.pcall_error + 1
        return false
    end

    if result == nil then
        errorCounts.nil_response = errorCounts.nil_response + 1
        return false
    elseif type(result) == "table" and result.Success == false then
        errorCounts.server_error = errorCounts.server_error + 1
        return false
    elseif result == true then
        return true
    end
    
    return false
end

-- Main attack function (MASS DESTRUCTION - hits up to 200 enemies)
local function autoAttackEnemies()
    local enemiesData = getValidEnemiesInRadius()
    if #enemiesData == 0 then
        errorCounts.no_enemies = errorCounts.no_enemies + 1
        currentEnemyIndex = 1
        return
    end

    local weapon = getWeapon()
    if not weapon then
        errorCounts.no_weapon = errorCounts.no_weapon + 1
        return
    end

    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then return end

    -- Attack up to 200 enemies this cycle (going ham)
    local successCount = 0
    local attemptCount = 0
    local maxToAttack = math.min(ENEMIES_PER_CYCLE, #enemiesData) -- don't exceed available enemies
    
    for i = 1, maxToAttack do
        if currentEnemyIndex > #enemiesData then
            currentEnemyIndex = 1
        end
        
        local enemyData = enemiesData[currentEnemyIndex]
        currentEnemyIndex = currentEnemyIndex + 1
        
        if enemyData and enemyData.enemy and enemyData.enemy.Parent then
            attemptCount = attemptCount + 1
            
            if attackSingleEnemy(enemyData, weapon) then
                successCount = successCount + 1
                totalEnemiesKilled = totalEnemiesKilled + 1
            end
            
            -- no delay between attacks (full speed mode)
        end
    end

    -- Report success
    if successCount > 0 then
        print("‚öîÔ∏è Hit x" .. successCount .. " enemies | Total hits: " .. totalEnemiesKilled)
        consecutiveFailures = 0
    else
        consecutiveFailures = consecutiveFailures + attemptCount
        reportFailures()
    end
    
    reportErrors()
end

-- Heartbeat loop
RunService.Heartbeat:Connect(function()
    if not AUTO_KILL_ENABLED then return end

    local currentTime = tick()
    if currentTime - lastAttackTime >= ATTACK_DELAY then
        autoAttackEnemies()
        lastAttackTime = currentTime
    end
end)

-- Toggle
local function toggleAutoKill()
    AUTO_KILL_ENABLED = not AUTO_KILL_ENABLED
    
    if AUTO_KILL_ENABLED then
        for key in pairs(errorCounts) do
            errorCounts[key] = 0
        end
        consecutiveFailures = 0
        totalEnemiesKilled = 0
        lastErrorReport = tick()
        lastFailureWarning = tick()
    else
        print("üìä Combat Stats:")
        print("  - Total hits: " .. totalEnemiesKilled)
        if consecutiveFailures > 0 then
            print("  - Consecutive failures: x" .. consecutiveFailures)
        end
    end
    
    print("=================================")
    print("‚öîÔ∏è Auto-Kill:", AUTO_KILL_ENABLED and "ENABLED (MASS DESTRUCTION)" or "DISABLED")
    print("Targets: UP TO", ENEMIES_PER_CYCLE, "enemies per cycle")
    print("Radius:", MAX_ATTACK_RADIUS, "studs | Delay:", ATTACK_DELAY .. "s")
    print("Press Z to toggle")
    print("=================================")
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Z then
        toggleAutoKill()
    end
end)

-- Startup message
print("=================================")
print("‚öîÔ∏è Auto-Kill loaded!")
print("Press Z to toggle ON/OFF")
print("MASS DESTRUCTION MODE - Up to", ENEMIES_PER_CYCLE, "enemies per cycle!")
print("Targets enemies in Characters folder")
print("=================================")
