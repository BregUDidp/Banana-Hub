local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

game.StarterGui:SetCore("SendNotification", {
    Title = "[  Aimbot Function  ]",
    Text = "________________________________________________________",
    Duration = 10
})
wait(1)

local Window = Rayfield:CreateWindow({
   Name = "   |  Aimbot  |  Mesui  [ V-8.2 ]",
   Icon = "scan-eye",
   LoadingTitle = "|  ðŸŽ¯  |  Aimbot   Function ",
   LoadingSubtitle = "____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________",
   ShowText = "Aimbot",
   Theme = "Brown",

   ToggleUIKeybind = "F",

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false,
   KeySettings = {
      Title = "",
      Subtitle = "",
      Note = "",
      FileName = "",
      SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"67"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local ESPTab = Window:CreateTab("Aimbot / ESP  [  1ï¸âƒ£  ]", "crosshair")
local Section = ESPTab:CreateSection("[ðŸŽ¯] à¹‚à¸‹à¸™à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™à¹à¸¥à¸°à¸¡à¸­à¸‡à¸„à¸™ [ðŸŽ¯]")

local Players       = game:GetService("Players")
local LocalPlayer   = Players.LocalPlayer
local Camera        = workspace.CurrentCamera
local UserInput     = game:GetService("UserInputService")
local RunService    = game:GetService("RunService")

local fovEnabled = false
local fovRadius = 150
local fovThickness = 2
local fovSpeed = 0.6
local fovFollowMouse = false
local fovCircle = nil
local DrawingAvailable = (typeof(Drawing) == "table" and typeof(Drawing.new) == "function")

--// Rainbow Color
local function getRainbowColor(speed, offset)
    local hue = (tick() * (speed or 1) + (offset or 0)) % 1
    return Color3.fromHSV(hue, 1, 1)
end

--// Create FOV Circle
local function createFOVCircle()
    if not DrawingAvailable or fovCircle then return end
    fovCircle = Drawing.new("Circle")
    fovCircle.Visible = false
    fovCircle.Radius = fovRadius
    fovCircle.Thickness = fovThickness
    fovCircle.NumSides = 100
    fovCircle.Filled = false
    fovCircle.Transparency = 1
end

--// FOV Render
RunService.RenderStepped:Connect(function()
    if not fovEnabled or not fovCircle then
        if fovCircle then fovCircle.Visible = false end
        return
    end

    local pos
    if fovFollowMouse then
        local mouse = UserInput:GetMouseLocation()
        pos = Vector2.new(mouse.X, mouse.Y)
    else
        local size = Camera.ViewportSize
        pos = Vector2.new(size.X / 2, size.Y / 2)
    end

    fovCircle.Position = pos
    fovCircle.Radius = fovRadius
    fovCircle.Thickness = fovThickness
    fovCircle.Color = autoTarget and Color3.fromRGB(255, 0, 0) or getRainbowColor(fovSpeed)
    fovCircle.Visible = true
end)

--// Find Closest in FOV
local function GetClosestInFOV()
    local closest = nil
    local closestDist = math.huge
    local mousePos = UserInput:GetMouseLocation()
    local centerPos = fovFollowMouse and mousePos or Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local headPos = player.Character.Head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)

                if onScreen then
                    local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
                    local distToCenter = (screenPoint - centerPos).Magnitude

                    if distToCenter <= fovRadius then
                        local distToMouse = (screenPoint - mousePos).Magnitude
                        if distToMouse < closestDist then
                            closestDist = distToMouse
                            closest = player
                        end
                    end
                end
            end
        end
    end
    return closest
end

--// ðŸ”¥ SMOOTH AIMBOT TOGGLE (à¸”à¹‰à¸²à¸™à¸šà¸™à¸ªà¸¸à¸”)
ESPTab:CreateToggle({
    Name = "[ ðŸŽ¯ ] à¸à¸²à¸£à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™  [ .à¸•à¹‰à¸­à¸‡à¹€à¸›à¸´à¸”à¸§à¸‡à¸à¸¥à¸¡à¸à¹ˆà¸­à¸™. ]",
    CurrentValue = false,
    Callback = function(val)
        aimbotOn = val
        if not val then autoTarget = nil end
    end
})

--// Smooth Aimbot Toggle
ESPTab:CreateToggle({
    Name = "[ âœ¨ ] à¸à¸²à¸£à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™à¹à¸šà¸šà¸¥à¸·à¹ˆà¸™à¹†  [ .à¸•à¹‰à¸­à¸‡à¹€à¸›à¸´à¸”à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸à¹ˆà¸­à¸™. ]",
    CurrentValue = true,
    Callback = function(val)
        smoothEnabled = val
    end
})

--// Smooth Speed Slider
ESPTab:CreateSlider({
    Name = "[ âš¡ ] à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¸‚à¸­à¸‡à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™  [ âš¡ ]",
    Range = {1, 30},
    Increment = 1,
    CurrentValue = 8,
    Suffix = "x",
    Callback = function(val)
        smoothSpeed = 0.12 / (val / 8)  -- à¹à¸›à¸¥à¸‡ 1-30 â†’ 0.22-0.03
    end
})

--// ðŸ”¥ SMOOTH AIMBOT LOOP (à¸™à¸¸à¹ˆà¸¡à¸™à¸§à¸¥ 100%)
RunService.RenderStepped:Connect(function()
    if aimbotOn and fovEnabled then
        autoTarget = GetClosestInFOV()
        
        if autoTarget and autoTarget.Character and autoTarget.Character:FindFirstChild("Head") then
            local targetPos = autoTarget.Character.Head.Position
            
            if smoothEnabled then
                -- ðŸ”¥ SMOOTH AIM: à¸«à¸¡à¸¸à¸™à¸à¸¥à¹‰à¸­à¸‡à¹à¸šà¸šà¸™à¸¸à¹ˆà¸¡à¸™à¸§à¸¥
                local currentCFrame = Camera.CFrame
                local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
                Camera.CFrame = currentCFrame:lerp(targetCFrame, smoothSpeed)
            else
                -- Instant Aim
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPos)
            end
        end
    else
        autoTarget = nil
    end
end)

ESPTab:CreateSection("[ðŸŒ€] à¹‚à¸‹à¸™à¹€à¸›à¸´à¸”à¸§à¸‡à¸à¸¥à¸¡à¸•à¸£à¸‡à¸«à¸™à¹‰à¸²à¸ˆà¸­ [ðŸŒ€]")

ESPTab:CreateToggle({
    Name = "[ ðŸŒ€ ] à¹€à¸›à¸´à¸”à¸§à¸‡à¸à¸¥à¸¡  [ .à¸§à¸‡à¸à¸¥à¸¡à¸«à¸™à¹‰à¸²à¸ˆà¸­. ]",
    CurrentValue = false,
    Callback = function(val)
        fovEnabled = val
        if val then createFOVCircle() end
    end
})

ESPTab:CreateToggle({
    Name = "[ ðŸ–±ï¸ ] à¸§à¸‡à¸à¸¥à¸¡à¸•à¸²à¸¡à¹€à¸¡à¸²à¸ªà¹Œ  [ .à¸§à¸‡à¸à¸¥à¸¡à¸ˆà¸°à¸•à¸²à¸¡à¹€à¸¡à¸²à¸ªà¹Œ. ]",
    CurrentValue = false,
    Callback = function(val)
        fovFollowMouse = val
    end
})

ESPTab:CreateSlider({
    Name = "[ ðŸ“ ] à¸›à¸£à¸±à¸šà¹€à¸ªà¹‰à¸™à¸§à¸‡à¸à¸¥à¸¡à¹ƒà¸«à¹‰à¹ƒà¸«à¸à¹ˆà¸‚à¸¶à¹‰à¸™  [ ðŸ“ ]",
    Range = {10, 1000},
    Increment = 1,
    CurrentValue = 150,
    Suffix = "px",
    Callback = function(val)
        fovRadius = val
        if fovCircle then fovCircle.Radius = val end
    end
})

ESPTab:CreateSlider({
    Name = "[ ðŸ“ ] à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¸«à¸™à¸²à¸‚à¸­à¸‡à¹€à¸ªà¹‰à¸™à¸§à¸‡à¸à¸¥à¸¡  [ ðŸ“ ]",
    Range = {1, 10},
    Increment = 1,
    CurrentValue = 2,
    Suffix = "px",
    Callback = function(val)
        fovThickness = val
        if fovCircle then fovCircle.Thickness = val end
    end
})

--// =================================== --
--//                ESP                 --
--// =================================== --

local espEnabled = false
local espTraceEnabled = true
local espBoxes = {}

local function rainbow(speed, offset)
    local t = tick() * (speed or 1) + (offset or 0)
    return Color3.fromHSV(t % 1, 1, 1)
end

local function createESP(player)
    if not DrawingAvailable or espBoxes[player] then return end
    local box = {}
    box.main = Drawing.new("Square")
    box.main.Thickness = 2
    box.main.Filled = false
    box.main.Visible = false

    box.name = Drawing.new("Text")
    box.name.Size = 16
    box.name.Center = true
    box.name.Outline = true
    box.name.Visible = false

    box.tracer = Drawing.new("Line")
    box.tracer.Thickness = 2
    box.tracer.Visible = false

    espBoxes[player] = box
end

local function removeESP(player)
    local box = espBoxes[player]
    if box then
        pcall(function()
            box.main:Remove()
            box.name:Remove()
            box.tracer:Remove()
        end)
        espBoxes[player] = nil
    end
end

RunService.RenderStepped:Connect(function()
    if not DrawingAvailable then return end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if espEnabled then
                    createESP(player)
                    local box = espBoxes[player]
                    local root = player.Character.HumanoidRootPart
                    local pos, onScreen = Camera:WorldToViewportPoint(root.Position)

                    if onScreen then
                        local scale = math.clamp(2000 / (Camera.CFrame.Position - root.Position).Magnitude, 20, 200)
                        local size = Vector2.new(scale * 0.6, scale)
                        local center = Vector2.new(pos.X, pos.Y)

                        box.main.Size = size
                        box.main.Position = center - size/2
                        box.main.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0)
                        box.main.Visible = true

                        box.name.Position = center + Vector2.new(0, -size.Y/2 - 18)
                        box.name.Text = player.Name .. ((autoTarget == player) and " ðŸŽ¯ à¹€à¸¥à¹‡à¸‡à¸«à¸±à¸§à¸•à¸±à¸§à¸¥à¸°à¸„à¸£à¹à¸¥à¹‰à¸§" or "")
                        box.name.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0.15)
                        box.name.Visible = true

                        if espTraceEnabled then
                            local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                            box.tracer.From = screenCenter
                            box.tracer.To = center
                            box.tracer.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0.25)
                            box.tracer.Visible = true
                        end
                    else
                        box.main.Visible = false
                        box.name.Visible = false
                        box.tracer.Visible = false
                    end
                else
                    removeESP(player)
                end
            else
                removeESP(player)
            end
        else
            removeESP(player)
        end
    end
end)

Players.PlayerRemoving:Connect(removeESP)

--// ESP UI
ESPTab:CreateSection("[ðŸ”] à¹‚à¸‹à¸™à¸¡à¸­à¸‡à¸”à¸¹à¸„à¸™à¹à¸šà¸šà¹€à¸ªà¹‡à¸™/à¹„à¸¡à¹ˆà¹€à¸ªà¹‰à¸™ [ðŸ”]")

ESPTab:CreateToggle({
    Name = "[ ðŸ” ] à¹€à¸›à¸´à¸”à¸à¸²à¸£à¸¡à¸­à¸‡à¹€à¸«à¹‡à¸™à¸„à¸™  [ .à¸ˆà¸°à¹€à¸›à¹‡à¸™à¹à¸šà¸šà¹€à¸ªà¹‰à¸™à¸•à¸£à¸‡. ]",
    CurrentValue = false,
    Callback = function(val)
        espEnabled = val
        if not val then
            for p,_ in pairs(espBoxes) do removeESP(p) end
        end
    end
})

ESPTab:CreateToggle({
    Name = "[ ðŸ” ] à¹€à¸›à¸´à¸”à¹€à¸ªà¹‰à¸™à¹à¸šà¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•  [ .à¹à¸šà¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•. ]",
    CurrentValue = true,
    Callback = function(val)
        espTraceEnabled = val
    end
})

local ATab = Window:CreateTab("Aimbot / ESP  [  2ï¸âƒ£  ]", "target")
local Section = ATab:CreateSection("[ðŸŽ¯] à¹‚à¸‹à¸™à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™à¹à¸šà¸šà¸”à¸µ [ðŸŽ¯]")

local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local cam = workspace.CurrentCamera
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local screenSize = cam.ViewportSize

-- Settings
local target = nil
local fovRadius = 120
local showFov = false  -- à¹€à¸£à¸´à¹ˆà¸¡à¸›à¸´à¸”
local smoothness = 0.12
local prediction = 0.135
local rainbowSpeed = 3
local rainbowHue = 0

-- Drawing Objects
local fovCircle = nil
local lockLine = nil
local targetName = nil
local hpText = nil

-- Rainbow Function
local function getRainbow()
    rainbowHue = (rainbowHue + (rainbowSpeed / 1000)) % 1
    return Color3.fromHSV(rainbowHue, 1, 1)
end

-- Create FOV Circle
local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    local c = Drawing.new("Circle")
    c.Thickness = 3
    c.Filled = false
    c.Transparency = 1
    c.NumSides = 80
    c.Position = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
    return c
end

-- Create Lock Line
local function createLockLine()
    if lockLine then lockLine:Remove() end
    local l = Drawing.new("Line")
    l.Thickness = 3
    l.Transparency = 1
    return l
end

-- Create Target Name
local function createTargetName()
    if targetName then targetName:Remove() end
    local t = Drawing.new("Text")
    t.Size = 18
    t.Center = true
    t.Outline = true
    t.Font = 2
    return t
end

-- Create HP Text
local function createHpText()
    if hpText then hpText:Remove() end
    local t = Drawing.new("Text")
    t.Size = 16
    t.Center = true
    t.Outline = true
    t.Font = 2
    return t
end

-- Initialize
fovCircle = createFovCircle()
lockLine = createLockLine()
targetName = createTargetName()
hpText = createHpText()

-- Get Closest in FOV
local function GetClosestInFOV()
    local closest = nil
    local dist = math.huge
    local center = Vector2.new(screenSize.X / 2, screenSize.Y / 2)

    for _, v in pairs(plrs:GetPlayers()) do
        if v ~= plr and v.Character and v.Character:FindFirstChild("Head") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            local head = v.Character.Head
            local pos, onScreen = cam:WorldToViewportPoint(head.Position)
            if onScreen then
                local screenPos = Vector2.new(pos.X, pos.Y)
                local mag = (screenPos - center).Magnitude
                if mag <= fovRadius and mag < dist then
                    dist = mag
                    closest = v
                end
            end
        end
    end
    return closest
end

-- Predict Position
local function getPredictedPosition(head)
    local root = head.Parent:FindFirstChild("HumanoidRootPart")
    if root then
        local v = root.Velocity
        local d = (cam.CFrame.Position - head.Position).Magnitude
        return head.Position + (v * d * prediction / 100)
    end
    return head.Position
end

-- Main Loop
run.RenderStepped:Connect(function()
    local rainbow = getRainbow()
    local center = Vector2.new(screenSize.X / 2, screenSize.Y / 2)

    -- FOV Circle + Aimbot Control
    if showFov then
        fovCircle.Position = center
        fovCircle.Radius = fovRadius
        fovCircle.Color = rainbow
        fovCircle.Visible = true

        -- Aimbot à¸—à¸³à¸‡à¸²à¸™à¹€à¸¡à¸·à¹ˆà¸­ FOV à¹€à¸›à¸´à¸”
        target = GetClosestInFOV()
        if target and target.Character and target.Character:FindFirstChild("Head") and target.Character:FindFirstChild("Humanoid") then
            local head = target.Character.Head
            local hum = target.Character.Humanoid
            local pred = getPredictedPosition(head)
            local targetCF = CFrame.new(cam.CFrame.Position, pred)
            cam.CFrame = cam.CFrame:Lerp(targetCF, smoothness)

            -- Lock Line
            local headPos = cam:WorldToViewportPoint(pred)
            lockLine.From = center
            lockLine.To = Vector2.new(headPos.X, headPos.Y)
            lockLine.Color = rainbow
            lockLine.Visible = true

            -- Target Name
            targetName.Text = target.DisplayName
            targetName.Position = Vector2.new(headPos.X, headPos.Y - 40)
            targetName.Color = rainbow
            targetName.Visible = true

            -- HP in FOV
            local hpPercent = math.floor((hum.Health / hum.MaxHealth) * 100)
            hpText.Text = hum.Health .. "/" .. hum.MaxHealth .. " (" .. hpPercent .. "%)"
            hpText.Position = center
            hpText.Color = rainbow
            hpText.Visible = true

            fovCircle.Thickness = 4  -- à¸«à¸™à¸²à¹€à¸¡à¸·à¹ˆà¸­à¸¥à¹‡à¸­à¸„
        else
            lockLine.Visible = false
            targetName.Visible = false
            hpText.Visible = false
            fovCircle.Thickness = 3
        end
    else
        -- à¸›à¸´à¸” FOV = à¸›à¸´à¸” Aimbot
        fovCircle.Visible = false
        lockLine.Visible = false
        targetName.Visible = false
        hpText.Visible = false
        target = nil
    end
end)

ATab:CreateParagraph({
    Title = "à¹€à¸¥à¸·à¸­à¸à¸”à¸¹à¸ªà¸„à¸£à¸´à¸›",
    Content = "[ à¹€à¸¥à¸·à¸­à¸à¸”à¸¹à¹à¸¡à¸žà¹€à¸ªà¸£à¹‡à¸ˆà¹€à¸‚à¹‰à¸²à¹à¸¡à¸žà¸™à¸±à¹‰à¸™à¹à¸¥à¹‰à¸§à¸£à¸±à¸™à¸ªà¸„à¸£à¸´à¸› ]"
})

-- GUI: à¹ƒà¸Šà¹‰à¸›à¸¸à¹ˆà¸¡ FOV à¹€à¸›à¹‡à¸™à¸›à¸¸à¹ˆà¸¡à¹€à¸›à¸´à¸” Aimbot
ATab:CreateToggle({
    Name = "[ ðŸŽ¯ ]  à¸›à¸´à¸”/à¹€à¸›à¸´à¸” à¸à¸²à¸£à¸¥à¹‡à¸­à¸„à¹€à¸›à¹‹à¸²à¸«à¸¡à¸²à¸¢à¸„à¸™à¹à¸šà¸šà¸¥à¸·à¹ˆà¸™à¹†  [ ðŸŽ¯ ]",
    CurrentState = false,
    Callback = function(v) 
        showFov = v
    end
})

ATab:CreateSlider({
    Name = "[ ðŸ“ ]  à¸›à¸£à¸±à¸šà¹€à¸ªà¹‰à¸™à¸§à¸‡à¸à¸¥à¸¡  [ ðŸ“ ]",
    Range = {50, 300}, Increment = 5, CurrentValue = 120,
    Callback = function(v) fovRadius = v end
})

ATab:CreateSlider({
    Name = "[ âš¡ ]  à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¸¥à¸·à¹ˆà¸™à¹„à¸«à¸¥à¸‚à¸­à¸‡à¸¥à¹‡à¸­à¸„à¹€à¸›à¹ˆà¸²  [ âš¡ ]",
    Range = {1, 30}, Increment = 1, CurrentValue = 12,
    Callback = function(v) smoothness = v / 100 end
})

ATab:CreateParagraph({
    Title = "à¹€à¸¥à¸·à¸­à¸à¸”à¸¹à¸ªà¸„à¸£à¸´à¸›à¸à¸²à¸£à¸¡à¸­à¸‡à¸”à¸¹à¸„à¸™",
    Content = "[ à¹€à¸¥à¸·à¸­à¸à¸”à¸¹à¹à¸¡à¸žà¹€à¸ªà¸£à¹‡à¸ˆà¹€à¸‚à¹‰à¸²à¹à¸¡à¸žà¸™à¸±à¹‰à¸™à¹à¸¥à¹‰à¸§à¸£à¸±à¸™à¸ªà¸„à¸£à¸´à¸› ]"
})

local espEnabled = false
local espTraceEnabled = true
local espBoxes = {}

local function rainbow(speed, offset)
    local t = tick() * (speed or 1) + (offset or 0)
    return Color3.fromHSV(t % 1, 1, 1)
end

local function createESP(player)
    if not DrawingAvailable or espBoxes[player] then return end
    local box = {}
    box.main = Drawing.new("Square")
    box.main.Thickness = 2
    box.main.Filled = false
    box.main.Visible = false

    box.name = Drawing.new("Text")
    box.name.Size = 16
    box.name.Center = true
    box.name.Outline = true
    box.name.Visible = false

    box.tracer = Drawing.new("Line")
    box.tracer.Thickness = 2
    box.tracer.Visible = false

    espBoxes[player] = box
end

local function removeESP(player)
    local box = espBoxes[player]
    if box then
        pcall(function()
            box.main:Remove()
            box.name:Remove()
            box.tracer:Remove()
        end)
        espBoxes[player] = nil
    end
end

RunService.RenderStepped:Connect(function()
    if not DrawingAvailable then return end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                if espEnabled then
                    createESP(player)
                    local box = espBoxes[player]
                    local root = player.Character.HumanoidRootPart
                    local pos, onScreen = Camera:WorldToViewportPoint(root.Position)

                    if onScreen then
                        local scale = math.clamp(2000 / (Camera.CFrame.Position - root.Position).Magnitude, 20, 200)
                        local size = Vector2.new(scale * 0.6, scale)
                        local center = Vector2.new(pos.X, pos.Y)

                        box.main.Size = size
                        box.main.Position = center - size/2
                        box.main.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0)
                        box.main.Visible = true

                        box.name.Position = center + Vector2.new(0, -size.Y/2 - 18)
                        box.name.Text = player.Name .. ((autoTarget == player) and " ðŸŽ¯ à¹€à¸¥à¹‡à¸‡à¸«à¸±à¸§à¸•à¸±à¸§à¸¥à¸°à¸„à¸£à¹à¸¥à¹‰à¸§" or "")
                        box.name.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0.15)
                        box.name.Visible = true

                        if espTraceEnabled then
                            local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                            box.tracer.From = screenCenter
                            box.tracer.To = center
                            box.tracer.Color = (autoTarget == player) and Color3.fromRGB(255, 0, 0) or rainbow(1, 0.25)
                            box.tracer.Visible = true
                        end
                    else
                        box.main.Visible = false
                        box.name.Visible = false
                        box.tracer.Visible = false
                    end
                else
                    removeESP(player)
                end
            else
                removeESP(player)
            end
        else
            removeESP(player)
        end
    end
end)

Players.PlayerRemoving:Connect(removeESP)

--// ESP UI
ATab:CreateSection("[ðŸ”] à¹‚à¸‹à¸™à¸¡à¸­à¸‡à¸”à¸¹à¸„à¸™à¹à¸šà¸šà¹€à¸ªà¹‡à¸™/à¹„à¸¡à¹ˆà¹€à¸ªà¹‰à¸™ [ðŸ”]")

ATab:CreateToggle({
    Name = "[ ðŸ” ] à¹€à¸›à¸´à¸”à¸à¸²à¸£à¸¡à¸­à¸‡à¹€à¸«à¹‡à¸™à¸„à¸™  [ .à¸ˆà¸°à¹€à¸›à¹‡à¸™à¹à¸šà¸šà¹€à¸ªà¹‰à¸™à¸•à¸£à¸‡. ]",
    CurrentValue = false,
    Callback = function(val)
        espEnabled = val
        if not val then
            for p,_ in pairs(espBoxes) do removeESP(p) end
        end
    end
})

ATab:CreateToggle({
    Name = "[ ðŸ” ] à¹€à¸›à¸´à¸”à¹€à¸ªà¹‰à¸™à¹à¸šà¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•  [ .à¹à¸šà¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•. ]",
    CurrentValue = true,
    Callback = function(val)
        espTraceEnabled = val
    end
})

-- à¹à¸—à¹‡à¸šà¸•à¸±à¸§à¸¥à¸°à¸„à¸£
local MainTab = Window:CreateTab("Player", "contact")
local MainSection = MainTab:CreateSection("[ðŸ›¸] à¹‚à¸‹à¸™à¸šà¸´à¸™à¹à¸¥à¸°à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¸šà¸´à¸™ [ðŸ›¸]")
 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character = player.Character or player.CharacterAdded:Wait()


UserInputService.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.Space then
		ascend = false
	elseif input.KeyCode == Enum.KeyCode.LeftShift then
		descend = false
	end
end)

-- à¸•à¸±à¸§à¹à¸›à¸£à¸£à¸°à¸šà¸š
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")
 
-- à¸•à¸±à¸§à¹à¸›à¸£à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™
local flying = false
local vv, gyro
local flySpeed = 50
local superSpeed = false
local runSpeed = 32
local noclipEnabled = false
local infJumpEnabled = false
 
-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸šà¸´à¸™
local function startFlying()
    if flying then return end
    flying = true
    humanoid.PlatformStand = true
 
    vv = Instance.new("BodyVelocity")
    vv.MaxForce = Vector3.new(1e5,1e5,1e5)
    vv.P = 1250
    vv.Velocity = Vector3.zero
    vv.Parent = hrp
 
    gyro = Instance.new("BodyGyro")
    gyro.MaxTorque = Vector3.new(4e5,4e5,4e5)
    gyro.P = 3000
    gyro.CFrame = hrp.CFrame
    gyro.Parent = hrp
 
    Rayfield:Notify({
        Title = "ðŸ›¸ à¹‚à¸«à¸¡à¸”à¸šà¸´à¸™à¹€à¸›à¸´à¸”!",
        Content = "à¹ƒà¸Šà¹‰ W,A,S,D,Space,Ctrl à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸šà¸„à¸¸à¸¡",
        Duration = 3,
        Image = 4483362458
    })
end
 
local function stopFlying()
    if not flying then return end
    flying = false
    if vv then vv:Destroy() vv=nil end
    if gyro then gyro:Destroy() gyro=nil end
    humanoid.PlatformStand = false
 
    Rayfield:Notify({
        Title = "ðŸ›¬ à¹‚à¸«à¸¡à¸”à¸šà¸´à¸™à¸›à¸´à¸”",
        Content = "à¸¥à¸‡à¸ˆà¸­à¸”à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢",
        Duration = 3,
        Image = 6026568198
    })
end
 
-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§
local function toggleSpeed(on)
    superSpeed = on
    humanoid.WalkSpeed = superSpeed and runSpeed or 16
    Rayfield:Notify({
        Title = superSpeed and "ðŸƒâ€â™‚ï¸ à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§ âœ…" or "ðŸš¶â€â™‚ï¸ à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§ ðŸ›‘",
        Content = superSpeed and "à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§à¸ªà¸¸à¸”à¸‚à¸µà¸”!" or "à¸à¸¥à¸±à¸šà¸ªà¸¹à¹ˆà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¸›à¸à¸•à¸´",
        Duration = 3,
        Image = 4483362458
    })
end

local flyToggle = MainTab:CreateToggle({Name="ðŸ›¸ à¹€à¸›à¸´à¸”/à¸›à¸´à¸” à¸à¸²à¸£à¸šà¸´à¸™", CurrentValue=false, Flag="FlyToggle", Callback=function(val) if val then startFlying() else stopFlying() end end})
local flySlider = MainTab:CreateSlider({Name="ðŸ“ à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¸šà¸´à¸™", Range={1,1000}, Increment=1, Suffix=" Speed", CurrentValue=50, Flag="FlySpeed", Callback=function(val) flySpeed=val end})
 
local Section2 = MainTab:CreateSection("[ðŸƒâ€â™€ï¸] à¹‚à¸‹à¸™à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§à¹à¸¥à¸°à¸›à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§ [ðŸƒâ€â™‚ï¸]")

local speedToggle = MainTab:CreateToggle({Name="ðŸƒâ€â™€ï¸ à¹€à¸›à¸´à¸”/à¸›à¸´à¸” à¸à¸²à¸£à¸§à¸´à¹ˆà¸‡à¹€à¸£à¹‡à¸§", CurrentValue=false, Flag="SpeedToggle", Callback=toggleSpeed})
local speedSlider = MainTab:CreateSlider({Name="ðŸ“ à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¹ƒà¸™à¸à¸²à¸£à¸§à¸´à¹ˆà¸‡", Range={1,1000}, Increment=1, Suffix=" Speed", CurrentValue=32, Flag="RunSpeed", Callback=function(val) runSpeed=val if superSpeed then humanoid.WalkSpeed=runSpeed end end})
 
local Section4 = MainTab:CreateSection("[ðŸ§±] à¹‚à¸‹à¸™à¸¥à¹ˆà¸­à¸‡à¸«à¸™à¹à¸¥à¸°à¸—à¸°à¸¥à¸¸à¸à¸³à¹à¸žà¸‡à¹à¸¥à¸°à¸à¸£à¸°à¹‚à¸”à¸”à¹„à¸¡à¹ˆà¸ˆà¸³à¸à¸±à¸” [ðŸ¦˜]")

--// à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™
local player = game.Players.LocalPlayer
local defaultSpeed = 16
local boostedSpeed = 48
local invis_on = false
local isSpeedBoosted = false
local key = Enum.KeyCode.X

--// à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¸µà¸¢à¸‡
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://942127495"
sound.Volume = 1
sound.Parent = player:WaitForChild("PlayerGui")

--// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸„à¸§à¸²à¸¡à¹‚à¸›à¸£à¹ˆà¸‡à¹ƒà¸ª
local function setTransparency(character, transparency)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("Decal") then
            part.Transparency = transparency
        end
    end
end

--// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸¥à¹ˆà¸­à¸‡à¸«à¸™
local function toggleInvisibility()
    invis_on = not invis_on
    sound:Play()

    if invis_on then
        local character = player.Character or player.CharacterAdded:Wait()
        local root = character:WaitForChild("HumanoidRootPart")
        local savedpos = root.CFrame

        wait()
        root.CFrame = CFrame.new(-25.95, 84, 3537.55)

        wait(0.15)
        local Seat = Instance.new("Seat", workspace)
        Seat.Anchored = false
        Seat.CanCollide = false
        Seat.Name = "invischair"
        Seat.Transparency = 1
        Seat.Position = Vector3.new(-25.95, 84, 3537.55)

        local Weld = Instance.new("Weld", Seat)
        Weld.Part0 = Seat
        Weld.Part1 = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")

        wait()
        Seat.CFrame = savedpos
        setTransparency(character, 0.5)

        game.StarterGui:SetCore("SendNotification", {
            Title = "à¸à¸²à¸£à¸¥à¹ˆà¸­à¸‡à¸«à¸™ [ âœ… ]",
            Text = "à¸ªà¸–à¸²à¸™à¸°: à¸¥à¹ˆà¸­à¸‡à¸«à¸™ ðŸ‘»",
            Duration = 3
        })
    else
        local invisChair = workspace:FindFirstChild("invischair")
        if invisChair then
            invisChair:Destroy()
        end
        setTransparency(player.Character, 0)

        game.StarterGui:SetCore("SendNotification", {
            Title = "à¸à¸²à¸£à¸¥à¹ˆà¸­à¸‡à¸«à¸™ [ ðŸ›‘ ]",
            Text = "à¸ªà¸–à¸²à¸™à¸°: à¸„à¸™à¹€à¸›à¹‡à¸™à¸›à¸à¸•à¸´",
            Duration = 3
        })
    end
end

MainTab:CreateButton({Name = "ðŸ‘» à¸à¸”à¸›à¸¸à¹ˆà¸¡à¸¥à¹ˆà¸­à¸‡à¸«à¸™ [ .à¸à¸”à¸•à¸±à¸§ X. ]  [ .à¸à¸”à¸­à¸µà¸à¸—à¸µà¹€à¸žà¸·à¹ˆà¸­à¸›à¸´à¸”. [ ðŸ›‘ ]", Callback = function() toggleInvisibility() end})

player.CharacterAdded:Connect(function(character)
    isSpeedBoosted = false
    local humanoid = character:WaitForChild("Humanoid")
    humanoid.WalkSpeed = defaultSpeed
end)

--// à¸„à¸µà¸¢à¹Œà¸¥à¸±à¸”à¸à¸” X
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == key then
        toggleInvisibility()
    end
end)

local noclipToggle = MainTab:CreateToggle({Name="ðŸ§± à¹€à¸›à¸´à¸”/à¸›à¸´à¸” à¸à¸²à¸£à¸—à¸°à¸¥à¸¸à¸à¸³à¹à¸žà¸‡", CurrentValue=false, Flag="NoclipToggle", Callback=function(val) noclipEnabled=val end})
local infJumpToggle = MainTab:CreateToggle({Name="ðŸ¦˜ à¹€à¸›à¸´à¸”/à¸›à¸´à¸” à¸à¸£à¸°à¹‚à¸”à¸”à¹„à¸¡à¹ˆà¸ˆà¸³à¸à¸±à¸”", CurrentValue=false, Flag="InfJumpToggle", Callback=function(val) infJumpEnabled=val end})

local Section5 = MainTab:CreateSection("[âš”ï¸]  à¸ªà¸„à¸£à¸´à¸›à¸”à¹‰à¸²à¸™à¸šà¸™à¹€à¸›à¹‡à¸™à¸ªà¸„à¸£à¸´à¸›à¸—à¸µà¹ˆà¸—à¸³à¹€à¸­à¸‡à¹à¸¥à¸°à¹€à¸›à¹‡à¸™à¸ªà¸„à¸£à¸´à¸›à¸—à¸µà¹ˆà¹‚à¸«à¸”à¸¡à¸²à¸  [âš”ï¸]")

-- à¸­à¸±à¸›à¹€à¸”à¸•à¸¥à¸¹à¸›
RS.RenderStepped:Connect(function()
    if flying and vv and gyro and hrp and humanoid then
        local cam = workspace.CurrentCamera
        if not cam then return end
 
        local flatForward = Vector3.new(cam.CFrame.LookVector.X,0,cam.CFrame.LookVector.Z)
        local forward = flatForward.Magnitude > 0 and flatForward.Unit or Vector3.zero
        local right = Vector3.new(cam.CFrame.RightVector.X,0,cam.CFrame.RightVector.Z)
        if right.Magnitude > 0 then right = right.Unit end
 
        local moveVec = Vector3.zero
        if UIS:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + Vector3.new(0,0,1) end
        if UIS:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec + Vector3.new(0,0,-1) end
        if UIS:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec + Vector3.new(-1,0,0) end
        if UIS:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + Vector3.new(1,0,0) end
        if UIS:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0,1,0) end
        if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then moveVec = moveVec + Vector3.new(0,-1,0) end
 
        local desired = forward*moveVec.Z + right*moveVec.X + Vector3.new(0,moveVec.Y,0)
        if desired.Magnitude>0 then desired = desired.Unit*flySpeed end
        vv.Velocity = desired
 
        if desired.Magnitude>1 then
            local flatDir = Vector3.new(desired.X,0,desired.Z)
            if flatDir.Magnitude>0 then gyro.CFrame = CFrame.new(hrp.Position,hrp.Position+flatDir) end
        end
    end
end)
 
RS.Stepped:Connect(function()
    if noclipEnabled and char then
        for _,part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide=false end
        end
    end
end)
 
UIS.JumpRequest:Connect(function()
    if infJumpEnabled and humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

UIS.JumpRequest:Connect(function()
    if infJumpEnabled and humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)
 
-- à¸£à¸µà¹€à¸‹à¹‡à¸•à¸•à¸±à¸§à¸¥à¸°à¸„à¸£à¹€à¸¡à¸·à¹ˆà¸­ respawn
player.CharacterAdded:Connect(function(c)
    char=c
    hrp=c:WaitForChild("HumanoidRootPart")
    humanoid=c:WaitForChild("Humanoid")
    stopFlying()
    toggleSpeed(false)
    noclipEnabled=false
    infJumpEnabled=false
    Rayfield:LoadConfiguration()
end)
